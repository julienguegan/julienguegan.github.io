<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="fr" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Dynamique des populations : écologie, EDO, logistique - Blog du Julien</title>
<meta name="description" content="Parmis les enjeux du 21ème siècle, l’écologie a un rôle majeure puisqu’elle est la science qui étudie les interactions des êtres vivants entre eux et avec leur milieu. Pour modéliser ces interactions, la dynamique des populations est la branche qui s’intéresse aux fluctuations démographiques des espèces. Ses applications sont nombreuses puisqu’elle peut permettre de répondre à des problèmes variés comme la gestion d’espèces menacées, la protection des cultures contre des nuisibles, le contrôle de bioréacteurs ou la prédiction des épidémies.  Modèle de Verhulst  A la fin du 18ème siècle, le modèle de Malthus décrit la variation d’une taille de population $y$ au cours du temps $t$ par l’équation différentielle ordinaire1 (EDO) :  [y’(t) = (n-m) y(t) = r y(t)]  avec les constantes : $n$ le taux de natalité, $m$ le taux de mortalité et $r$ le taux de croissance. Ce modèle nous dit que, selon le taux de croissance $r$, la taille des populations peut soit diminuer, rester constante ou augmenter de manière exponentielle. Ce modèle ne reflète pas la réalité puisque une population n’augmentera jamais à l’infini.         En 1840, Verlhust propose un modèle de croissance plus adapté en partant de l’hypothèse que le taux de croissance $r$ n’est pas une constante mais est fonction affine de la taille de population $y$ :  [y’(t) = \big(n(y) - m(y)\big) y(t)]  Verlhust part notamment de l’hypothèse que plus la taille d’une population augmente alors plus son taux de natalité $n$ diminue et plus son taux de mortalité $m$ augmente. En partant de cette hypothèse et en appliquant quelques manipulations algébriques astucieuses, on peut montrer que l’équation différentielle précédente peut se réécrire sous la forme :  [y’(t) = r y(t) \left(1 - \frac{y(t)}{K}\right)]  avec $K$ une constante appelée capacité d’accueil. On peut résoudre analytiquement cette équation avec la condition initiale $y(t=0)=y_0$, on obtient la solution logistique :  [y(t) = \frac{K}{1+\left(\frac{K}{y_0}-1\right)e^{-rt}}]            Résolution détaillée de l&#39;équation différentielle logistique par séparation de variable    $$   \begin{align*}     \int_{y_0}^{y(t)} \frac{1}{y(1-y/K)}dy &amp;= \int_0^t r \ d\tau \\     \int_{y_0}^{y(t)} \frac{K}{y(K-y)}dy &amp;= \int_0^t r \ d\tau \\     \int_{y_0}^{y(t)} \frac{1}{y}dy +  \int_{y_0}^{y(t)} \frac{1}{K-1}dy &amp;= \int_0^t r \ d\tau \\     \ln \left| \frac{y(t)}{y_0} \right| - \ln \left| \frac{K-y(t)}{K-y_0} \right| &amp;= r \ t \\     \ln \left( \frac{y(t)\big(K-y_0\big)}{y_0\big(K-y(t)\big)} \right) &amp;= r \ t \\     \frac{y(t)}{K-y(t)} &amp;= \frac{y_0}{K-y_0}e^{rt} \\     y(t)\left(1+\frac{y_0}{K-y_0}e^{rt} \right) &amp;= \frac{K y_0 e^{rt}}{K-y_0} \\     y(t) &amp;= \frac{Ky_0e^{rt}}{K-y_0+y_0e^{rt}} \\     y(t) &amp;= \frac{K y_0}{(K-y_0)e^{-rt}+y_0} \\   \end{align*} \\   \square   $$   On remarque que $ \lim\limits_{t\to\infty} y(t) = K $. Ce qui signifie que peut importe la taille de la population initiale $y_0$, la population finira toujours par tendre vers $K$ la capacité d’accueil qu’on qualifie souvent comme le nombre d’individus maximal que le milieu peut accueillir (selon l’espace, les ressources …). Cette fonction dite logistique introduite pour la première fois par Verlhust pour modéliser la croissance des populations trouvera par la suite plein d’application dans des domaines variés comme l’économie, la chimie, les statistiques et plus récemment les réseaux de neurones artificielles.  Modèle de Lotka-Volterra  Les modèles de Lotka-Volterra sont des sytèmes d’équations simples qui sont apparus au début du 20ème siècle. Ils portent le nom de deux mathématiciens qui ont publié en même temps mais indépendamment sur le sujet : Volterra, en 1926, pour modéliser les populations de sardines et de leurs prédateurs et Lotka, en 1924, dans son livre Elements of Physical Biology. Contrairement au modèle de Verlhust qui s’intéresse à une seule population, les modèles de Lotka-Volterra modélisent les interactions entre plusieurs espèces, chacune ayant un impact sur le développement de l’autres.         Proie-prédateur  Le modèle proie-prédateur de Lotka-Volterra a permis d’expliquer des données collectées de certaines populations d’animaux comme le lynx et lièvre ainsi que le loup et l’élan aux Etats-Unis. On y représente l’évolution du nombre proies $x$ et de prédateurs $y$ au cours du temps $t$ selon le modèle suivant :  [\left{   \begin{array}{ccc}     x’(t) = x(t)\ \big(\alpha - \beta y(t)\big)      y’(t) = y(t)\ \big( \delta x(t) - \gamma\big)   \end{array} \right.]  avec les paramètres $\alpha$ et $\delta$ sont les taux de reproduction respectivement des proies et des prédateurs et $\beta$ et $\gamma$ sont les taux de mortalité, respectivement, des proies et des prédateurs.  Note: On parle de système autonome : le temps $t$ n’apparaît pas explicitement dans les équations.  Si on développe chacune des équations, on peut plus facilement donner une interprétation. Pour les proies, on a d’une part le terme $\alpha x(t)$ qui modélise la croissance exponentielle avec une source illimitée de nourriture et d’autre part $- \beta x(t) y(t)$ qui représente la prédation proportionnelle à la fréquence de rencontre entre prédateurs et proies. L’équation des prédateurs est très semblable à celle des proies, $\delta x(t)y(t)$ est la croissance des prédateurs proportionnelle à la quantité de nourriture disponible (les proies) et $- \gamma y(t)$ représente la mort naturelle des prédateurs.         On peut caculer les équilibres de ce système d’équations différentielles et également en déduire un comportement mais les solutions n’ont pas d’expression analytique simple. Néanmoins, il est possible de calculer une solution approchée numériquement (plus de détails dans la section suivante).  # define ODE function to resolve r, c, m, b = 3, 4, 1, 2 def prey_predator(XY, t=0):     dX = r*XY[0] - c*XY[0]*XY[1]     dY = b*XY[0]*XY[1] - m*XY[1]     return [dX, dY]  # discretization T0   = 0 Tmax = 12 n    = 200 T    = np.linspace(T0, Tmax, n)   Je calcule ici l’évolution des 2 populations en fonction du temps pour une condition initiale fixée, on voit qu’elles ont un comportement périodique et en décalage de phase. # TEMPORAL DYNAMIC X0 = [1,1] solution = integrate.odeint(prey_predator, X0, T) # use scipy solver         Ici, je calcule plusieurs solutions pour différentes conditions initiales que j’affiche dans l’espace de phase (le temps n’appararaît pas). J’affiche également le champ de vecteur généré par le système d’équation avec plt.quiver() pour une grille de valeur.  # PHASES SPACE # some trajectories orbits = [] for i in range(5):     X0    = [0.2+i*0.1, 0.2+i*0.1]     orbit = integrate.odeint(prey_predator, X0, T)     orbits.append(orbit)  # vector field x, y             = np.linspace(0, 2.5, 20), np.linspace(0, 2, 20) X_grid, Y_grid   = np.meshgrid(x, y)                       DX_grid, DY_grid = prey_predator([X_grid, Y_grid]) N                = np.sqrt(DX_grid ** 2 + DY_grid ** 2)  N[N==0]          = 1 DX_grid, DY_grid = DX_grid/N, DY_grid/N          Attention: Les unités des simulations ne reflète pas la réalité, il faut des populations suffisamment grandes pour que la modélisation soit correcte.  Dans le modèle utilisé, les prédateurs prospèrent lorsque les proies sont nombreuses, mais finissent par épuiser leurs ressources et déclinent. Lorsque la population de prédateurs a suffisamment diminué, les proies profitant du répit se reproduisent et leur population augmente de nouveau. Cette dynamique se poursuit en un cycle de croissance et déclin. Il existe 2 équilibres : le point $(0,0)$ est un point de selle instable qui montre que l’extinction des 2 espèce est difficile à obtenir et le point $(\frac{\gamma}{\delta}, \frac{\alpha}{\beta})$ est un centre stable, les populations oscillent autour cet état.  Note: Cette modélisation reste assez simple, un grande nombre de variante existe. On peut rajouter des termes de disparition des 2 espèces (dus à la pêche, chasse, pesticide …), tenir compte de la capacité d’accueil du milieu en utilisant un terme logistique.  Compétition  Le modèle de compétition de Lotka-Volterra est une variante du modèle de prédation où les 2 espèces n’ont pas une hierarchie de proies et prédateurs mais sont en compétition l’une et l’autre. De plus, la dynamique de base n’est plus une simple croissance exponentielle mais logistique (avec les paramètres $r_i$ et $K_i$) :  [\left{   \begin{array}{ccc}     x_1’(t) = r_1x_1(t)\left(1- \frac{x_1(t)+\alpha_{12}x_2(t)}{K_1}\right)      x_2’(t) = r_2x_2(t)\left(1- \frac{x_2(t)+\alpha_{21}x_1(t)}{K_2}\right)   \end{array} \right.]  avec $\alpha_{12}$ l’effet de l’espèce 2 sur la population de l’espèce 1 et réciproquement $\alpha{21}$ l’effet de l’espèce 2 sur l’espèce 1. Par exemple, pour l’équation de l’espèce 1, le coefficient $\alpha_{12}$ est multiplié par la taille de la population $x_2$. Quand $\alpha_{12} &lt; 1$ alors l’effet de l’espèce 2 sur l’espèce 1 est plus petit que l’effet de l’espèce 1 sur ces propres membres. Et inversement, quand $\alpha_{12} &gt; 1$, l’effet de l’espèce 2 sur l’espèce 1 est supérieur à l’effet de l’espèce 1 sur ces propres membres.         Pour comprendre plus en détails les prédictions du modèles, il est utile de tracer comme précédemment les diagrammes d’espace de phase $(x_1,x_2)$. On peut distinguer 4 scénarios selon les valeurs des coefficients de compétition, j’affiche ci-dessous les champs de vecteurs de ces scénarios avec plt.streamplot() ainsi que les isoclines, les courbes pour lesquelles \(x_1&#39;(t)=0\) ou \(x_2&#39;(t)=0\):        # define ODE to resolve r1, K1 = 3, 1 r2, K2 = 3, 1 def competition(X1X2, a1, a2):     dX1 = r1*X1X2[0] * (1-(X1X2[0]+a1*X1X2[1])/K1)     dX2 = r2*X1X2[1] * (1-(X1X2[1]+a2*X1X2[0])/K2)     return [dX1, dX2]  # compute derivatives for each scenario N = 20 x, y = np.linspace(0, 2.5, N), np.linspace(0, 2, N) X_grid, Y_grid = np.meshgrid(x, y) DX_grid, DY_grid = np.zeros((4,N,N)), np.zeros((4,N,N)) coeffs = np.array([[1.5,1.5],[0.5,0.5],[1.5,0.5],[0.5,1.5]]) for k,(a1,a2) in enumerate(coeffs):     DX_grid[k,:], DY_grid[k,:] = competition([X_grid, Y_grid], a1, a2)   Au final, les 4 comportements possibles en fonction de $\alpha_{12}$ et $\alpha_{21}$ sont les suivants :     Exclusion compétitive d’une des deux espèces en fonction des conditions initiales.   Coexistence stable des deux espèces.   Exclusion compétitive de l’espèce 1 par l’espèce 2.   Exclusion compétitive de l’espèce 2 par l’espèce 1.   La coexistence stable des 2 espèces n’est possible que si $\alpha_{12} &lt; 1$ et $\alpha_{21} &lt; 1$, c’est-à-dire qu’il faut que la compétition interspécifique soit plus faible que la compétition intraspécifique.  Méthode numérique pour les EDO  Cette section est un petit peu à part du réel sujet de ce post puisque j’y introduis les méthodes numériques pour résoudre les équations différentielles. En effet, il est possible de déduire de nombreuses propriétés d’un système d’EDO en se basant sur les théorèmes mathématiques pour la théorie des systèmes dynamiques (comme méthode de Lyapunov, invariance de LaSalle, théorème de Poincaré-Bendixon …) mais seul un nombre restreint d’équations différentielles admettent une solution analytique. En pratique, on préfère souvent avoir une méthode qui calcule une solution approximative du problème. On considère le problème \(y&#39;(t) = f\big(t,y(t)\big)\) avec $y(t_0)=y_0$. L’idée des méthodes numériques est de résoudre le problème sur un ensemble discret de points $(t_n,y_n)$ avec $h_n=t_{n+1}-t_n$, un pas de temps fixé.  Euler   La méthode d’Euler est la plus basique des méthodes numériques pour EDO, elle utilise l’équation différentielle pour calculer la pente de la tangente à n’importe quel point de la courbe solution. La solution est approchée en partant du point initial $y_0$ connu pour lequel on calcule la tangente, on fait ensuite un pas de temps le long de cette tangente on obtient alors un nouveau point $y_1$. L’idée est de répéter ce processus, pour un pas de temps de $t_n$ à $t_{n+1}$ on peut l’écrire comme $y_{n+1} = y_n + h f(t_n,y_n)$.  Cette méthode est très simple à mettre en place, par exemple en python : def Euler_method(f, y0, t):     y = np.zeros((len(t), len(y0)))     y[0,:] = y0     for i in range(len(t)-1):         y[i+1] = y[i] + h*f(y[i], t[i])     return y   Runge-Kutta   And now we’re going to shift things to the right align. Again, there should be plenty of room above, below, and to the left of the image. Just look at him there — Hey guy! Way to rock that right side. I don’t care what the left aligned image says, you look great. Don’t let anyone else tell you differently. $ y_{n+1} = y_n + \frac{h}{6} (k_1+2k_2+2k_3+k_4) $  test  def RungeKutta4_method(f, y0, t):     y = np.zeros((len(t), len(y0)))     y[0] = y0     for i in range(len(t)-1):         k1 = f(y[i], t[i])         k2 = f(y[i]+k1*h/2, t[i]+h/2)         k3 = f(y[i]+k2*h/2, t[i]+h/2)         k4 = f(y[i]+k3*h, t[i]+h)         y[i+1] = y[i] + (h/6) * (k1 + 2*k2 + 2*k3 + k4)     return y   Exemple  # initial condition y0 = [2, 0] # discretization t = np.linspace(0, 5*pi, 100) h = t[1] - t[0] # ODE formulation def problem(y, t):     return np.array([y[1], -y[0]]) # analytic solution def exact_solution(t):     return y0[0]*np.cos(t) y_exact = exact_solution(t) y_euler = Euler_method(problem, y0, t)[:, 0] y_rk4   = RungeKutta4_method(problem, y0, t)[:, 0]      La méthode RK4 est une méthode d’ordre 4, ce qui signifie que l’erreur commise à chaque étape est de l’ordre de h5, alors que l’erreur totale accumulée est de l’ordre de h4.  The Euler method is a first-order method, which means that the local error (error per step) is proportional to the square of the step size, and the global error (error at a given time) is proportional to the step size                             Le terme ordinaire est utilisé par opposition au terme équation différentielle partielle (ou équation aux dérivées partielles) où la ou les fonctions inconnues peuvent dépendre de plusieurs variables. &#8617;">


  <meta name="author" content="Julien Guégan">
  
  <meta property="article:author" content="Julien Guégan">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="fr_FR">
<meta property="og:site_name" content="Blog du Julien">
<meta property="og:title" content="Dynamique des populations : écologie, EDO, logistique">
<meta property="og:url" content="http://localhost:4000/posts/2021-08-11-dynamique_des_populations/">


  <meta property="og:description" content="Parmis les enjeux du 21ème siècle, l’écologie a un rôle majeure puisqu’elle est la science qui étudie les interactions des êtres vivants entre eux et avec leur milieu. Pour modéliser ces interactions, la dynamique des populations est la branche qui s’intéresse aux fluctuations démographiques des espèces. Ses applications sont nombreuses puisqu’elle peut permettre de répondre à des problèmes variés comme la gestion d’espèces menacées, la protection des cultures contre des nuisibles, le contrôle de bioréacteurs ou la prédiction des épidémies.  Modèle de Verhulst  A la fin du 18ème siècle, le modèle de Malthus décrit la variation d’une taille de population $y$ au cours du temps $t$ par l’équation différentielle ordinaire1 (EDO) :  [y’(t) = (n-m) y(t) = r y(t)]  avec les constantes : $n$ le taux de natalité, $m$ le taux de mortalité et $r$ le taux de croissance. Ce modèle nous dit que, selon le taux de croissance $r$, la taille des populations peut soit diminuer, rester constante ou augmenter de manière exponentielle. Ce modèle ne reflète pas la réalité puisque une population n’augmentera jamais à l’infini.         En 1840, Verlhust propose un modèle de croissance plus adapté en partant de l’hypothèse que le taux de croissance $r$ n’est pas une constante mais est fonction affine de la taille de population $y$ :  [y’(t) = \big(n(y) - m(y)\big) y(t)]  Verlhust part notamment de l’hypothèse que plus la taille d’une population augmente alors plus son taux de natalité $n$ diminue et plus son taux de mortalité $m$ augmente. En partant de cette hypothèse et en appliquant quelques manipulations algébriques astucieuses, on peut montrer que l’équation différentielle précédente peut se réécrire sous la forme :  [y’(t) = r y(t) \left(1 - \frac{y(t)}{K}\right)]  avec $K$ une constante appelée capacité d’accueil. On peut résoudre analytiquement cette équation avec la condition initiale $y(t=0)=y_0$, on obtient la solution logistique :  [y(t) = \frac{K}{1+\left(\frac{K}{y_0}-1\right)e^{-rt}}]            Résolution détaillée de l&#39;équation différentielle logistique par séparation de variable    $$   \begin{align*}     \int_{y_0}^{y(t)} \frac{1}{y(1-y/K)}dy &amp;= \int_0^t r \ d\tau \\     \int_{y_0}^{y(t)} \frac{K}{y(K-y)}dy &amp;= \int_0^t r \ d\tau \\     \int_{y_0}^{y(t)} \frac{1}{y}dy +  \int_{y_0}^{y(t)} \frac{1}{K-1}dy &amp;= \int_0^t r \ d\tau \\     \ln \left| \frac{y(t)}{y_0} \right| - \ln \left| \frac{K-y(t)}{K-y_0} \right| &amp;= r \ t \\     \ln \left( \frac{y(t)\big(K-y_0\big)}{y_0\big(K-y(t)\big)} \right) &amp;= r \ t \\     \frac{y(t)}{K-y(t)} &amp;= \frac{y_0}{K-y_0}e^{rt} \\     y(t)\left(1+\frac{y_0}{K-y_0}e^{rt} \right) &amp;= \frac{K y_0 e^{rt}}{K-y_0} \\     y(t) &amp;= \frac{Ky_0e^{rt}}{K-y_0+y_0e^{rt}} \\     y(t) &amp;= \frac{K y_0}{(K-y_0)e^{-rt}+y_0} \\   \end{align*} \\   \square   $$   On remarque que $ \lim\limits_{t\to\infty} y(t) = K $. Ce qui signifie que peut importe la taille de la population initiale $y_0$, la population finira toujours par tendre vers $K$ la capacité d’accueil qu’on qualifie souvent comme le nombre d’individus maximal que le milieu peut accueillir (selon l’espace, les ressources …). Cette fonction dite logistique introduite pour la première fois par Verlhust pour modéliser la croissance des populations trouvera par la suite plein d’application dans des domaines variés comme l’économie, la chimie, les statistiques et plus récemment les réseaux de neurones artificielles.  Modèle de Lotka-Volterra  Les modèles de Lotka-Volterra sont des sytèmes d’équations simples qui sont apparus au début du 20ème siècle. Ils portent le nom de deux mathématiciens qui ont publié en même temps mais indépendamment sur le sujet : Volterra, en 1926, pour modéliser les populations de sardines et de leurs prédateurs et Lotka, en 1924, dans son livre Elements of Physical Biology. Contrairement au modèle de Verlhust qui s’intéresse à une seule population, les modèles de Lotka-Volterra modélisent les interactions entre plusieurs espèces, chacune ayant un impact sur le développement de l’autres.         Proie-prédateur  Le modèle proie-prédateur de Lotka-Volterra a permis d’expliquer des données collectées de certaines populations d’animaux comme le lynx et lièvre ainsi que le loup et l’élan aux Etats-Unis. On y représente l’évolution du nombre proies $x$ et de prédateurs $y$ au cours du temps $t$ selon le modèle suivant :  [\left{   \begin{array}{ccc}     x’(t) = x(t)\ \big(\alpha - \beta y(t)\big)      y’(t) = y(t)\ \big( \delta x(t) - \gamma\big)   \end{array} \right.]  avec les paramètres $\alpha$ et $\delta$ sont les taux de reproduction respectivement des proies et des prédateurs et $\beta$ et $\gamma$ sont les taux de mortalité, respectivement, des proies et des prédateurs.  Note: On parle de système autonome : le temps $t$ n’apparaît pas explicitement dans les équations.  Si on développe chacune des équations, on peut plus facilement donner une interprétation. Pour les proies, on a d’une part le terme $\alpha x(t)$ qui modélise la croissance exponentielle avec une source illimitée de nourriture et d’autre part $- \beta x(t) y(t)$ qui représente la prédation proportionnelle à la fréquence de rencontre entre prédateurs et proies. L’équation des prédateurs est très semblable à celle des proies, $\delta x(t)y(t)$ est la croissance des prédateurs proportionnelle à la quantité de nourriture disponible (les proies) et $- \gamma y(t)$ représente la mort naturelle des prédateurs.         On peut caculer les équilibres de ce système d’équations différentielles et également en déduire un comportement mais les solutions n’ont pas d’expression analytique simple. Néanmoins, il est possible de calculer une solution approchée numériquement (plus de détails dans la section suivante).  # define ODE function to resolve r, c, m, b = 3, 4, 1, 2 def prey_predator(XY, t=0):     dX = r*XY[0] - c*XY[0]*XY[1]     dY = b*XY[0]*XY[1] - m*XY[1]     return [dX, dY]  # discretization T0   = 0 Tmax = 12 n    = 200 T    = np.linspace(T0, Tmax, n)   Je calcule ici l’évolution des 2 populations en fonction du temps pour une condition initiale fixée, on voit qu’elles ont un comportement périodique et en décalage de phase. # TEMPORAL DYNAMIC X0 = [1,1] solution = integrate.odeint(prey_predator, X0, T) # use scipy solver         Ici, je calcule plusieurs solutions pour différentes conditions initiales que j’affiche dans l’espace de phase (le temps n’appararaît pas). J’affiche également le champ de vecteur généré par le système d’équation avec plt.quiver() pour une grille de valeur.  # PHASES SPACE # some trajectories orbits = [] for i in range(5):     X0    = [0.2+i*0.1, 0.2+i*0.1]     orbit = integrate.odeint(prey_predator, X0, T)     orbits.append(orbit)  # vector field x, y             = np.linspace(0, 2.5, 20), np.linspace(0, 2, 20) X_grid, Y_grid   = np.meshgrid(x, y)                       DX_grid, DY_grid = prey_predator([X_grid, Y_grid]) N                = np.sqrt(DX_grid ** 2 + DY_grid ** 2)  N[N==0]          = 1 DX_grid, DY_grid = DX_grid/N, DY_grid/N          Attention: Les unités des simulations ne reflète pas la réalité, il faut des populations suffisamment grandes pour que la modélisation soit correcte.  Dans le modèle utilisé, les prédateurs prospèrent lorsque les proies sont nombreuses, mais finissent par épuiser leurs ressources et déclinent. Lorsque la population de prédateurs a suffisamment diminué, les proies profitant du répit se reproduisent et leur population augmente de nouveau. Cette dynamique se poursuit en un cycle de croissance et déclin. Il existe 2 équilibres : le point $(0,0)$ est un point de selle instable qui montre que l’extinction des 2 espèce est difficile à obtenir et le point $(\frac{\gamma}{\delta}, \frac{\alpha}{\beta})$ est un centre stable, les populations oscillent autour cet état.  Note: Cette modélisation reste assez simple, un grande nombre de variante existe. On peut rajouter des termes de disparition des 2 espèces (dus à la pêche, chasse, pesticide …), tenir compte de la capacité d’accueil du milieu en utilisant un terme logistique.  Compétition  Le modèle de compétition de Lotka-Volterra est une variante du modèle de prédation où les 2 espèces n’ont pas une hierarchie de proies et prédateurs mais sont en compétition l’une et l’autre. De plus, la dynamique de base n’est plus une simple croissance exponentielle mais logistique (avec les paramètres $r_i$ et $K_i$) :  [\left{   \begin{array}{ccc}     x_1’(t) = r_1x_1(t)\left(1- \frac{x_1(t)+\alpha_{12}x_2(t)}{K_1}\right)      x_2’(t) = r_2x_2(t)\left(1- \frac{x_2(t)+\alpha_{21}x_1(t)}{K_2}\right)   \end{array} \right.]  avec $\alpha_{12}$ l’effet de l’espèce 2 sur la population de l’espèce 1 et réciproquement $\alpha{21}$ l’effet de l’espèce 2 sur l’espèce 1. Par exemple, pour l’équation de l’espèce 1, le coefficient $\alpha_{12}$ est multiplié par la taille de la population $x_2$. Quand $\alpha_{12} &lt; 1$ alors l’effet de l’espèce 2 sur l’espèce 1 est plus petit que l’effet de l’espèce 1 sur ces propres membres. Et inversement, quand $\alpha_{12} &gt; 1$, l’effet de l’espèce 2 sur l’espèce 1 est supérieur à l’effet de l’espèce 1 sur ces propres membres.         Pour comprendre plus en détails les prédictions du modèles, il est utile de tracer comme précédemment les diagrammes d’espace de phase $(x_1,x_2)$. On peut distinguer 4 scénarios selon les valeurs des coefficients de compétition, j’affiche ci-dessous les champs de vecteurs de ces scénarios avec plt.streamplot() ainsi que les isoclines, les courbes pour lesquelles \(x_1&#39;(t)=0\) ou \(x_2&#39;(t)=0\):        # define ODE to resolve r1, K1 = 3, 1 r2, K2 = 3, 1 def competition(X1X2, a1, a2):     dX1 = r1*X1X2[0] * (1-(X1X2[0]+a1*X1X2[1])/K1)     dX2 = r2*X1X2[1] * (1-(X1X2[1]+a2*X1X2[0])/K2)     return [dX1, dX2]  # compute derivatives for each scenario N = 20 x, y = np.linspace(0, 2.5, N), np.linspace(0, 2, N) X_grid, Y_grid = np.meshgrid(x, y) DX_grid, DY_grid = np.zeros((4,N,N)), np.zeros((4,N,N)) coeffs = np.array([[1.5,1.5],[0.5,0.5],[1.5,0.5],[0.5,1.5]]) for k,(a1,a2) in enumerate(coeffs):     DX_grid[k,:], DY_grid[k,:] = competition([X_grid, Y_grid], a1, a2)   Au final, les 4 comportements possibles en fonction de $\alpha_{12}$ et $\alpha_{21}$ sont les suivants :     Exclusion compétitive d’une des deux espèces en fonction des conditions initiales.   Coexistence stable des deux espèces.   Exclusion compétitive de l’espèce 1 par l’espèce 2.   Exclusion compétitive de l’espèce 2 par l’espèce 1.   La coexistence stable des 2 espèces n’est possible que si $\alpha_{12} &lt; 1$ et $\alpha_{21} &lt; 1$, c’est-à-dire qu’il faut que la compétition interspécifique soit plus faible que la compétition intraspécifique.  Méthode numérique pour les EDO  Cette section est un petit peu à part du réel sujet de ce post puisque j’y introduis les méthodes numériques pour résoudre les équations différentielles. En effet, il est possible de déduire de nombreuses propriétés d’un système d’EDO en se basant sur les théorèmes mathématiques pour la théorie des systèmes dynamiques (comme méthode de Lyapunov, invariance de LaSalle, théorème de Poincaré-Bendixon …) mais seul un nombre restreint d’équations différentielles admettent une solution analytique. En pratique, on préfère souvent avoir une méthode qui calcule une solution approximative du problème. On considère le problème \(y&#39;(t) = f\big(t,y(t)\big)\) avec $y(t_0)=y_0$. L’idée des méthodes numériques est de résoudre le problème sur un ensemble discret de points $(t_n,y_n)$ avec $h_n=t_{n+1}-t_n$, un pas de temps fixé.  Euler   La méthode d’Euler est la plus basique des méthodes numériques pour EDO, elle utilise l’équation différentielle pour calculer la pente de la tangente à n’importe quel point de la courbe solution. La solution est approchée en partant du point initial $y_0$ connu pour lequel on calcule la tangente, on fait ensuite un pas de temps le long de cette tangente on obtient alors un nouveau point $y_1$. L’idée est de répéter ce processus, pour un pas de temps de $t_n$ à $t_{n+1}$ on peut l’écrire comme $y_{n+1} = y_n + h f(t_n,y_n)$.  Cette méthode est très simple à mettre en place, par exemple en python : def Euler_method(f, y0, t):     y = np.zeros((len(t), len(y0)))     y[0,:] = y0     for i in range(len(t)-1):         y[i+1] = y[i] + h*f(y[i], t[i])     return y   Runge-Kutta   And now we’re going to shift things to the right align. Again, there should be plenty of room above, below, and to the left of the image. Just look at him there — Hey guy! Way to rock that right side. I don’t care what the left aligned image says, you look great. Don’t let anyone else tell you differently. $ y_{n+1} = y_n + \frac{h}{6} (k_1+2k_2+2k_3+k_4) $  test  def RungeKutta4_method(f, y0, t):     y = np.zeros((len(t), len(y0)))     y[0] = y0     for i in range(len(t)-1):         k1 = f(y[i], t[i])         k2 = f(y[i]+k1*h/2, t[i]+h/2)         k3 = f(y[i]+k2*h/2, t[i]+h/2)         k4 = f(y[i]+k3*h, t[i]+h)         y[i+1] = y[i] + (h/6) * (k1 + 2*k2 + 2*k3 + k4)     return y   Exemple  # initial condition y0 = [2, 0] # discretization t = np.linspace(0, 5*pi, 100) h = t[1] - t[0] # ODE formulation def problem(y, t):     return np.array([y[1], -y[0]]) # analytic solution def exact_solution(t):     return y0[0]*np.cos(t) y_exact = exact_solution(t) y_euler = Euler_method(problem, y0, t)[:, 0] y_rk4   = RungeKutta4_method(problem, y0, t)[:, 0]      La méthode RK4 est une méthode d’ordre 4, ce qui signifie que l’erreur commise à chaque étape est de l’ordre de h5, alors que l’erreur totale accumulée est de l’ordre de h4.  The Euler method is a first-order method, which means that the local error (error per step) is proportional to the square of the step size, and the global error (error at a given time) is proportional to the step size                             Le terme ordinaire est utilisé par opposition au terme équation différentielle partielle (ou équation aux dérivées partielles) où la ou les fonctions inconnues peuvent dépendre de plusieurs variables. &#8617;">



  <meta property="og:image" content="http://localhost:4000/assets/images/teaser_dynamique_population.jpg">





  <meta property="article:published_time" content="2021-08-12T04:18:30+02:00">






<link rel="canonical" href="http://localhost:4000/posts/2021-08-11-dynamique_des_populations/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Julien Guégan",
      "url": "http://localhost:4000/",
      "sameAs": ["https://www.linkedin.com/in/julien-gu%C3%A9gan-852a30138/","https://www.facebook.com/julien.guegan.754","https://github.com/julienguegan","https://www.instagram.com/julien_guegan_/?hl=fr"]
    
  }
</script>


  <meta name="google-site-verification" content="_Cj2FZGjDR1sECXPRL64_CMVDm6adbKqCXSLHArYdSE" />






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Blog du Julien Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="shortcut icon" type="image/png" href="/assets/images/brain_icon.png">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



<!-- Load KaTeX -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        // • rendering keys, e.g.:
        throwOnError : false
      });
  });
</script>
    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/brain_icon.png" alt="Blog du Julien"></a>
        
        <a class="site-title" href="/">
          Blog du Julien
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/home/">Home</a>
            </li><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li><li class="masthead__menu-item">
              <a href="/cv/">CV</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/images/photo_profil.jpg" alt="Julien Guégan" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Julien Guégan</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Je m’appelle Julien, je suis ingénieur en trucs et machins et j’aime ceci et cela. Je parle ici de bidouille.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Contact</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li><a href="mailto:julienguegan56520@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Mail</span></a></li>
          
        
          
            <li><a href="https://www.linkedin.com/in/julien-gu%C3%A9gan-852a30138/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">Linkedin</span></a></li>
          
        
          
            <li><a href="https://www.facebook.com/julien.guegan.754" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-facebook-square" aria-hidden="true"></i><span class="label">Facebook</span></a></li>
          
        
          
            <li><a href="https://github.com/julienguegan" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
            <li><a href="https://www.instagram.com/julien_guegan_/?hl=fr" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i><span class="label">Instagram</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Dynamique des populations : écologie, EDO, logistique">
    <meta itemprop="description" content="Parmis les enjeux du 21ème siècle, l’écologie a un rôle majeure puisqu’elle est la science qui étudie les interactions des êtres vivants entre eux et avec leur milieu. Pour modéliser ces interactions, la dynamique des populations est la branche qui s’intéresse aux fluctuations démographiques des espèces. Ses applications sont nombreuses puisqu’elle peut permettre de répondre à des problèmes variés comme la gestion d’espèces menacées, la protection des cultures contre des nuisibles, le contrôle de bioréacteurs ou la prédiction des épidémies.Modèle de VerhulstA la fin du 18ème siècle, le modèle de Malthus décrit la variation d’une taille de population $y$ au cours du temps $t$ par l’équation différentielle ordinaire1 (EDO) :[y’(t) = (n-m) y(t) = r y(t)]avec les constantes : $n$ le taux de natalité, $m$ le taux de mortalité et $r$ le taux de croissance. Ce modèle nous dit que, selon le taux de croissance $r$, la taille des populations peut soit diminuer, rester constante ou augmenter de manière exponentielle. Ce modèle ne reflète pas la réalité puisque une population n’augmentera jamais à l’infini.   En 1840, Verlhust propose un modèle de croissance plus adapté en partant de l’hypothèse que le taux de croissance $r$ n’est pas une constante mais est fonction affine de la taille de population $y$ :[y’(t) = \big(n(y) - m(y)\big) y(t)]Verlhust part notamment de l’hypothèse que plus la taille d’une population augmente alors plus son taux de natalité $n$ diminue et plus son taux de mortalité $m$ augmente. En partant de cette hypothèse et en appliquant quelques manipulations algébriques astucieuses, on peut montrer que l’équation différentielle précédente peut se réécrire sous la forme :[y’(t) = r y(t) \left(1 - \frac{y(t)}{K}\right)]avec $K$ une constante appelée capacité d’accueil. On peut résoudre analytiquement cette équation avec la condition initiale $y(t=0)=y_0$, on obtient la solution logistique :[y(t) = \frac{K}{1+\left(\frac{K}{y_0}-1\right)e^{-rt}}]     Résolution détaillée de l&#39;équation différentielle logistique par séparation de variable  $$  \begin{align*}    \int_{y_0}^{y(t)} \frac{1}{y(1-y/K)}dy &amp;= \int_0^t r \ d\tau \\    \int_{y_0}^{y(t)} \frac{K}{y(K-y)}dy &amp;= \int_0^t r \ d\tau \\    \int_{y_0}^{y(t)} \frac{1}{y}dy +  \int_{y_0}^{y(t)} \frac{1}{K-1}dy &amp;= \int_0^t r \ d\tau \\    \ln \left| \frac{y(t)}{y_0} \right| - \ln \left| \frac{K-y(t)}{K-y_0} \right| &amp;= r \ t \\    \ln \left( \frac{y(t)\big(K-y_0\big)}{y_0\big(K-y(t)\big)} \right) &amp;= r \ t \\    \frac{y(t)}{K-y(t)} &amp;= \frac{y_0}{K-y_0}e^{rt} \\    y(t)\left(1+\frac{y_0}{K-y_0}e^{rt} \right) &amp;= \frac{K y_0 e^{rt}}{K-y_0} \\    y(t) &amp;= \frac{Ky_0e^{rt}}{K-y_0+y_0e^{rt}} \\    y(t) &amp;= \frac{K y_0}{(K-y_0)e^{-rt}+y_0} \\  \end{align*} \\  \square  $$On remarque que $ \lim\limits_{t\to\infty} y(t) = K $. Ce qui signifie que peut importe la taille de la population initiale $y_0$, la population finira toujours par tendre vers $K$ la capacité d’accueil qu’on qualifie souvent comme le nombre d’individus maximal que le milieu peut accueillir (selon l’espace, les ressources …). Cette fonction dite logistique introduite pour la première fois par Verlhust pour modéliser la croissance des populations trouvera par la suite plein d’application dans des domaines variés comme l’économie, la chimie, les statistiques et plus récemment les réseaux de neurones artificielles.Modèle de Lotka-VolterraLes modèles de Lotka-Volterra sont des sytèmes d’équations simples qui sont apparus au début du 20ème siècle. Ils portent le nom de deux mathématiciens qui ont publié en même temps mais indépendamment sur le sujet : Volterra, en 1926, pour modéliser les populations de sardines et de leurs prédateurs et Lotka, en 1924, dans son livre Elements of Physical Biology. Contrairement au modèle de Verlhust qui s’intéresse à une seule population, les modèles de Lotka-Volterra modélisent les interactions entre plusieurs espèces, chacune ayant un impact sur le développement de l’autres.   Proie-prédateurLe modèle proie-prédateur de Lotka-Volterra a permis d’expliquer des données collectées de certaines populations d’animaux comme le lynx et lièvre ainsi que le loup et l’élan aux Etats-Unis. On y représente l’évolution du nombre proies $x$ et de prédateurs $y$ au cours du temps $t$ selon le modèle suivant :[\left{  \begin{array}{ccc}    x’(t) = x(t)\ \big(\alpha - \beta y(t)\big)     y’(t) = y(t)\ \big( \delta x(t) - \gamma\big)  \end{array}\right.]avec les paramètres $\alpha$ et $\delta$ sont les taux de reproduction respectivement des proies et des prédateurs et $\beta$ et $\gamma$ sont les taux de mortalité, respectivement, des proies et des prédateurs.Note: On parle de système autonome : le temps $t$ n’apparaît pas explicitement dans les équations.Si on développe chacune des équations, on peut plus facilement donner une interprétation. Pour les proies, on a d’une part le terme $\alpha x(t)$ qui modélise la croissance exponentielle avec une source illimitée de nourriture et d’autre part $- \beta x(t) y(t)$ qui représente la prédation proportionnelle à la fréquence de rencontre entre prédateurs et proies. L’équation des prédateurs est très semblable à celle des proies, $\delta x(t)y(t)$ est la croissance des prédateurs proportionnelle à la quantité de nourriture disponible (les proies) et $- \gamma y(t)$ représente la mort naturelle des prédateurs.   On peut caculer les équilibres de ce système d’équations différentielles et également en déduire un comportement mais les solutions n’ont pas d’expression analytique simple. Néanmoins, il est possible de calculer une solution approchée numériquement (plus de détails dans la section suivante).# define ODE function to resolver, c, m, b = 3, 4, 1, 2def prey_predator(XY, t=0):    dX = r*XY[0] - c*XY[0]*XY[1]    dY = b*XY[0]*XY[1] - m*XY[1]    return [dX, dY]# discretizationT0   = 0Tmax = 12n    = 200T    = np.linspace(T0, Tmax, n) Je calcule ici l’évolution des 2 populations en fonction du temps pour une condition initiale fixée, on voit qu’elles ont un comportement périodique et en décalage de phase.# TEMPORAL DYNAMICX0 = [1,1]solution = integrate.odeint(prey_predator, X0, T) # use scipy solver   Ici, je calcule plusieurs solutions pour différentes conditions initiales que j’affiche dans l’espace de phase (le temps n’appararaît pas). J’affiche également le champ de vecteur généré par le système d’équation avec plt.quiver() pour une grille de valeur.# PHASES SPACE# some trajectoriesorbits = []for i in range(5):    X0    = [0.2+i*0.1, 0.2+i*0.1]    orbit = integrate.odeint(prey_predator, X0, T)    orbits.append(orbit) # vector fieldx, y             = np.linspace(0, 2.5, 20), np.linspace(0, 2, 20)X_grid, Y_grid   = np.meshgrid(x, y)                      DX_grid, DY_grid = prey_predator([X_grid, Y_grid])N                = np.sqrt(DX_grid ** 2 + DY_grid ** 2) N[N==0]          = 1DX_grid, DY_grid = DX_grid/N, DY_grid/N   Attention: Les unités des simulations ne reflète pas la réalité, il faut des populations suffisamment grandes pour que la modélisation soit correcte.Dans le modèle utilisé, les prédateurs prospèrent lorsque les proies sont nombreuses, mais finissent par épuiser leurs ressources et déclinent. Lorsque la population de prédateurs a suffisamment diminué, les proies profitant du répit se reproduisent et leur population augmente de nouveau. Cette dynamique se poursuit en un cycle de croissance et déclin. Il existe 2 équilibres : le point $(0,0)$ est un point de selle instable qui montre que l’extinction des 2 espèce est difficile à obtenir et le point $(\frac{\gamma}{\delta}, \frac{\alpha}{\beta})$ est un centre stable, les populations oscillent autour cet état.Note: Cette modélisation reste assez simple, un grande nombre de variante existe. On peut rajouter des termes de disparition des 2 espèces (dus à la pêche, chasse, pesticide …), tenir compte de la capacité d’accueil du milieu en utilisant un terme logistique.CompétitionLe modèle de compétition de Lotka-Volterra est une variante du modèle de prédation où les 2 espèces n’ont pas une hierarchie de proies et prédateurs mais sont en compétition l’une et l’autre. De plus, la dynamique de base n’est plus une simple croissance exponentielle mais logistique (avec les paramètres $r_i$ et $K_i$) :[\left{  \begin{array}{ccc}    x_1’(t) = r_1x_1(t)\left(1- \frac{x_1(t)+\alpha_{12}x_2(t)}{K_1}\right)     x_2’(t) = r_2x_2(t)\left(1- \frac{x_2(t)+\alpha_{21}x_1(t)}{K_2}\right)  \end{array}\right.]avec $\alpha_{12}$ l’effet de l’espèce 2 sur la population de l’espèce 1 et réciproquement $\alpha{21}$ l’effet de l’espèce 2 sur l’espèce 1. Par exemple, pour l’équation de l’espèce 1, le coefficient $\alpha_{12}$ est multiplié par la taille de la population $x_2$. Quand $\alpha_{12} &lt; 1$ alors l’effet de l’espèce 2 sur l’espèce 1 est plus petit que l’effet de l’espèce 1 sur ces propres membres. Et inversement, quand $\alpha_{12} &gt; 1$, l’effet de l’espèce 2 sur l’espèce 1 est supérieur à l’effet de l’espèce 1 sur ces propres membres.   Pour comprendre plus en détails les prédictions du modèles, il est utile de tracer comme précédemment les diagrammes d’espace de phase $(x_1,x_2)$. On peut distinguer 4 scénarios selon les valeurs des coefficients de compétition, j’affiche ci-dessous les champs de vecteurs de ces scénarios avec plt.streamplot() ainsi que les isoclines, les courbes pour lesquelles \(x_1&#39;(t)=0\) ou \(x_2&#39;(t)=0\):  # define ODE to resolver1, K1 = 3, 1r2, K2 = 3, 1def competition(X1X2, a1, a2):    dX1 = r1*X1X2[0] * (1-(X1X2[0]+a1*X1X2[1])/K1)    dX2 = r2*X1X2[1] * (1-(X1X2[1]+a2*X1X2[0])/K2)    return [dX1, dX2]# compute derivatives for each scenarioN = 20x, y = np.linspace(0, 2.5, N), np.linspace(0, 2, N)X_grid, Y_grid = np.meshgrid(x, y)DX_grid, DY_grid = np.zeros((4,N,N)), np.zeros((4,N,N))coeffs = np.array([[1.5,1.5],[0.5,0.5],[1.5,0.5],[0.5,1.5]])for k,(a1,a2) in enumerate(coeffs):    DX_grid[k,:], DY_grid[k,:] = competition([X_grid, Y_grid], a1, a2)Au final, les 4 comportements possibles en fonction de $\alpha_{12}$ et $\alpha_{21}$ sont les suivants :  Exclusion compétitive d’une des deux espèces en fonction des conditions initiales.  Coexistence stable des deux espèces.  Exclusion compétitive de l’espèce 1 par l’espèce 2.  Exclusion compétitive de l’espèce 2 par l’espèce 1.La coexistence stable des 2 espèces n’est possible que si $\alpha_{12} &lt; 1$ et $\alpha_{21} &lt; 1$, c’est-à-dire qu’il faut que la compétition interspécifique soit plus faible que la compétition intraspécifique.Méthode numérique pour les EDOCette section est un petit peu à part du réel sujet de ce post puisque j’y introduis les méthodes numériques pour résoudre les équations différentielles. En effet, il est possible de déduire de nombreuses propriétés d’un système d’EDO en se basant sur les théorèmes mathématiques pour la théorie des systèmes dynamiques (comme méthode de Lyapunov, invariance de LaSalle, théorème de Poincaré-Bendixon …) mais seul un nombre restreint d’équations différentielles admettent une solution analytique. En pratique, on préfère souvent avoir une méthode qui calcule une solution approximative du problème. On considère le problème \(y&#39;(t) = f\big(t,y(t)\big)\) avec $y(t_0)=y_0$. L’idée des méthodes numériques est de résoudre le problème sur un ensemble discret de points $(t_n,y_n)$ avec $h_n=t_{n+1}-t_n$, un pas de temps fixé.Euler La méthode d’Euler est la plus basique des méthodes numériques pour EDO, elle utilise l’équation différentielle pour calculer la pente de la tangente à n’importe quel point de la courbe solution. La solution est approchée en partant du point initial $y_0$ connu pour lequel on calcule la tangente, on fait ensuite un pas de temps le long de cette tangente on obtient alors un nouveau point $y_1$. L’idée est de répéter ce processus, pour un pas de temps de $t_n$ à $t_{n+1}$ on peut l’écrire comme $y_{n+1} = y_n + h f(t_n,y_n)$.Cette méthode est très simple à mettre en place, par exemple en python :def Euler_method(f, y0, t):    y = np.zeros((len(t), len(y0)))    y[0,:] = y0    for i in range(len(t)-1):        y[i+1] = y[i] + h*f(y[i], t[i])    return yRunge-Kutta And now we’re going to shift things to the right align. Again, there should be plenty of room above, below, and to the left of the image. Just look at him there — Hey guy! Way to rock that right side. I don’t care what the left aligned image says, you look great. Don’t let anyone else tell you differently. $ y_{n+1} = y_n + \frac{h}{6} (k_1+2k_2+2k_3+k_4) $testdef RungeKutta4_method(f, y0, t):    y = np.zeros((len(t), len(y0)))    y[0] = y0    for i in range(len(t)-1):        k1 = f(y[i], t[i])        k2 = f(y[i]+k1*h/2, t[i]+h/2)        k3 = f(y[i]+k2*h/2, t[i]+h/2)        k4 = f(y[i]+k3*h, t[i]+h)        y[i+1] = y[i] + (h/6) * (k1 + 2*k2 + 2*k3 + k4)    return yExemple# initial conditiony0 = [2, 0]# discretizationt = np.linspace(0, 5*pi, 100)h = t[1] - t[0]# ODE formulationdef problem(y, t):    return np.array([y[1], -y[0]])# analytic solutiondef exact_solution(t):    return y0[0]*np.cos(t)y_exact = exact_solution(t)y_euler = Euler_method(problem, y0, t)[:, 0]y_rk4   = RungeKutta4_method(problem, y0, t)[:, 0]    La méthode RK4 est une méthode d’ordre 4, ce qui signifie que l’erreur commise à chaque étape est de l’ordre de h5, alors que l’erreur totale accumulée est de l’ordre de h4.The Euler method is a first-order method, which means that the local error (error per step) is proportional to the square of the step size, and the global error (error at a given time) is proportional to the step size                 Le terme ordinaire est utilisé par opposition au terme équation différentielle partielle (ou équation aux dérivées partielles) où la ou les fonctions inconnues peuvent dépendre de plusieurs variables. &#8617;      ">
    <meta itemprop="datePublished" content="2021-08-12T04:18:30+02:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="http://localhost:4000/posts/2021-08-11-dynamique_des_populations/" class="u-url" itemprop="url">Dynamique des populations : écologie, EDO, logistique
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          10 minute(s) de lecture
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <p class="text-justify">Parmis les enjeux du 21<sup>ème</sup> siècle, l’écologie a un rôle majeure puisqu’elle est la science qui étudie les interactions des êtres vivants entre eux et avec leur milieu. Pour modéliser ces interactions, la dynamique des populations est la branche qui s’intéresse aux fluctuations démographiques des espèces. Ses applications sont nombreuses puisqu’elle peut permettre de répondre à des problèmes variés comme la gestion d’espèces menacées, la protection des cultures contre des nuisibles, le contrôle de bioréacteurs ou la prédiction des épidémies.</p>

<h2 id="modèle-de-verhulst">Modèle de Verhulst</h2>

<p>A la fin du 18<sup>ème</sup> siècle, le modèle de <strong>Malthus</strong> décrit la variation d’une taille de population $y$ au cours du temps $t$ par l’équation différentielle ordinaire<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> (EDO) :</p>

\[y'(t) = (n-m) y(t) = r y(t)\]

<p>avec les constantes : $n$ le taux de natalité, $m$ le taux de mortalité et $r$ le taux de croissance. Ce modèle nous dit que, selon le taux de croissance $r$, la taille des populations peut soit diminuer, rester constante ou augmenter de manière exponentielle. Ce modèle ne reflète pas la réalité puisque une population n’augmentera jamais à l’infini.</p>

<p align="center">
   <img src="/assets/images/malthus_verlhust_photos.png" width="50%" />
</p>

<p>En 1840, <strong>Verlhust</strong> propose un modèle de croissance plus adapté en partant de l’hypothèse que le taux de croissance $r$ n’est pas une constante mais est fonction affine de la taille de population $y$ :</p>

\[y'(t) = \big(n(y) - m(y)\big) y(t)\]

<p>Verlhust part notamment de l’hypothèse que plus la taille d’une population augmente alors plus son taux de natalité $n$ diminue et plus son taux de mortalité $m$ augmente. En partant de cette hypothèse et en appliquant quelques manipulations algébriques astucieuses, on peut montrer que l’équation différentielle précédente peut se réécrire sous la forme :</p>

\[y'(t) = r y(t) \left(1 - \frac{y(t)}{K}\right)\]

<p>avec $K$ une constante appelée <em>capacité d’accueil</em>. On peut résoudre analytiquement cette équation avec la condition initiale $y(t=0)=y_0$, on obtient la <strong>solution logistique</strong> :</p>

\[y(t) = \frac{K}{1+\left(\frac{K}{y_0}-1\right)e^{-rt}}\]

<p align="center">
   <img src="/assets/images/verlhust_graph.png" width="70%" />
</p>

<details class="notice--primary">
  <summary>Résolution détaillée de l'équation différentielle logistique par séparation de variable</summary>

  $$
  \begin{align*}
    \int_{y_0}^{y(t)} \frac{1}{y(1-y/K)}dy &amp;= \int_0^t r \ d\tau \\
    \int_{y_0}^{y(t)} \frac{K}{y(K-y)}dy &amp;= \int_0^t r \ d\tau \\
    \int_{y_0}^{y(t)} \frac{1}{y}dy +  \int_{y_0}^{y(t)} \frac{1}{K-1}dy &amp;= \int_0^t r \ d\tau \\
    \ln \left| \frac{y(t)}{y_0} \right| - \ln \left| \frac{K-y(t)}{K-y_0} \right| &amp;= r \ t \\
    \ln \left( \frac{y(t)\big(K-y_0\big)}{y_0\big(K-y(t)\big)} \right) &amp;= r \ t \\
    \frac{y(t)}{K-y(t)} &amp;= \frac{y_0}{K-y_0}e^{rt} \\
    y(t)\left(1+\frac{y_0}{K-y_0}e^{rt} \right) &amp;= \frac{K y_0 e^{rt}}{K-y_0} \\
    y(t) &amp;= \frac{Ky_0e^{rt}}{K-y_0+y_0e^{rt}} \\
    y(t) &amp;= \frac{K y_0}{(K-y_0)e^{-rt}+y_0} \\
  \end{align*} \\
  \square
  $$
</details>

<p class="text-justify">On remarque que $ \lim\limits_{t\to\infty} y(t) = K $. Ce qui signifie que peut importe la taille de la population initiale $y_0$, la population finira toujours par tendre vers $K$ la capacité d’accueil qu’on qualifie souvent comme le nombre d’individus maximal que le milieu peut accueillir (selon l’espace, les ressources …). Cette <a href="https://fr.wikipedia.org/wiki/Fonction_logistique_(Verhulst)">fonction dite logistique</a> introduite pour la première fois par Verlhust pour modéliser la croissance des populations trouvera par la suite plein d’application dans des domaines variés comme l’économie, la chimie, les statistiques et plus récemment les réseaux de neurones artificielles.</p>

<h2 id="modèle-de-lotka-volterra">Modèle de Lotka-Volterra</h2>

<p class="text-justify">Les modèles de Lotka-Volterra sont des sytèmes d’équations simples qui sont apparus au début du 20<sup>ème</sup> siècle. Ils portent le nom de deux mathématiciens qui ont publié en même temps mais indépendamment sur le sujet : Volterra, en 1926, pour modéliser les populations de sardines et de leurs prédateurs et Lotka, en 1924, dans son livre <em>Elements of Physical Biology</em>. Contrairement au modèle de Verlhust qui s’intéresse à une seule population, les modèles de Lotka-Volterra modélisent les interactions entre plusieurs espèces, chacune ayant un impact sur le développement de l’autres.</p>

<p align="center">
   <img src="/assets/images/lotka_volterra_photos.png" width="50%" />
</p>

<h3 id="proie-prédateur"><em>Proie-prédateur</em></h3>

<p class="text-justify">Le modèle proie-prédateur de Lotka-Volterra a permis d’expliquer des données collectées de certaines populations d’animaux comme le lynx et lièvre ainsi que le loup et l’élan aux Etats-Unis. On y représente l’évolution du nombre proies $x$ et de prédateurs $y$ au cours du temps $t$ selon le modèle suivant :</p>

\[\left\{
  \begin{array}{ccc}
    x'(t) = x(t)\ \big(\alpha - \beta y(t)\big) \\
    y'(t) = y(t)\ \big( \delta x(t) - \gamma\big)
  \end{array}
\right.\]

<p class="text-justify">avec les paramètres $\alpha$ et $\delta$ sont les taux de reproduction respectivement des proies et des prédateurs et $\beta$ et $\gamma$ sont les taux de mortalité, respectivement, des proies et des prédateurs.</p>

<p class="notice--primary"><strong>Note:</strong> On parle de système autonome : le temps $t$ n’apparaît pas explicitement dans les équations.</p>

<p class="text-justify">Si on développe chacune des équations, on peut plus facilement donner une interprétation. Pour les proies, on a d’une part le terme $\alpha x(t)$ qui modélise la croissance exponentielle avec une source illimitée de nourriture et d’autre part $- \beta x(t) y(t)$ qui représente la prédation proportionnelle à la fréquence de rencontre entre prédateurs et proies. L’équation des prédateurs est très semblable à celle des proies, $\delta x(t)y(t)$ est la croissance des prédateurs proportionnelle à la quantité de nourriture disponible (les proies) et $- \gamma y(t)$ représente la mort naturelle des prédateurs.</p>

<p align="center">
   <img src="/assets/images/fox_rabbit.gif" width="70%" />
</p>

<p class="text-justify">On peut caculer les équilibres de ce système d’équations différentielles et également en déduire un comportement mais les solutions n’ont pas d’expression analytique simple. Néanmoins, il est possible de calculer une solution approchée numériquement (plus de détails dans la <a href="#méthode-numérique-pour-les-edo"><code class="language-plaintext highlighter-rouge">section suivante</code></a>).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># define ODE function to resolve
</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="k">def</span> <span class="nf">prey_predator</span><span class="p">(</span><span class="n">XY</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dY</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dX</span><span class="p">,</span> <span class="n">dY</span><span class="p">]</span>
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># discretization
</span><span class="n">T0</span>   <span class="o">=</span> <span class="mi">0</span>
<span class="n">Tmax</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">n</span>    <span class="o">=</span> <span class="mi">200</span>
<span class="n">T</span>    <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">Tmax</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> 
</code></pre></div></div>
<p>Je calcule ici l’évolution des 2 populations en fonction du temps pour une condition initiale fixée, on voit qu’elles ont un comportement périodique et en décalage de phase.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># TEMPORAL DYNAMIC
</span><span class="n">X0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">prey_predator</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="c1"># use scipy solver
</span></code></pre></div></div>
<p align="center">
   <img src="/assets/images/lotka_volterra_graph2.png" width="70%" />
</p>

<p>Ici, je calcule plusieurs solutions pour différentes conditions initiales que j’affiche dans l’espace de phase (le temps n’appararaît pas). J’affiche également le champ de vecteur généré par le système d’équation avec <code class="language-plaintext highlighter-rouge">plt.quiver()</code> pour une grille de valeur.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PHASES SPACE
# some trajectories
</span><span class="n">orbits</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">X0</span>    <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mf">0.1</span><span class="p">]</span>
    <span class="n">orbit</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">prey_predator</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">orbits</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span> 
<span class="c1"># vector field
</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span>             <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">X_grid</span><span class="p">,</span> <span class="n">Y_grid</span>   <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>                      
<span class="n">DX_grid</span><span class="p">,</span> <span class="n">DY_grid</span> <span class="o">=</span> <span class="n">prey_predator</span><span class="p">([</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">Y_grid</span><span class="p">])</span>
<span class="n">N</span>                <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">DX_grid</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">DY_grid</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> 
<span class="n">N</span><span class="p">[</span><span class="n">N</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>          <span class="o">=</span> <span class="mi">1</span>
<span class="n">DX_grid</span><span class="p">,</span> <span class="n">DY_grid</span> <span class="o">=</span> <span class="n">DX_grid</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">DY_grid</span><span class="o">/</span><span class="n">N</span>
</code></pre></div></div>

<p align="center">
   <img src="/assets/images/lotka_volterra_graph1.png" width="70%" />
</p>

<p class="notice--danger"><strong>Attention:</strong> Les unités des simulations ne reflète pas la réalité, il faut des populations suffisamment grandes pour que la modélisation soit correcte.</p>

<p class="text-justify">Dans le modèle utilisé, les prédateurs prospèrent lorsque les proies sont nombreuses, mais finissent par épuiser leurs ressources et déclinent. Lorsque la population de prédateurs a suffisamment diminué, les proies profitant du répit se reproduisent et leur population augmente de nouveau. Cette dynamique se poursuit en un cycle de croissance et déclin. Il existe 2 équilibres : le point $(0,0)$ est un point de selle instable qui montre que l’extinction des 2 espèce est difficile à obtenir et le point $(\frac{\gamma}{\delta}, \frac{\alpha}{\beta})$ est un centre stable, les populations oscillent autour cet état.</p>

<p class="notice--info"><strong>Note:</strong> Cette modélisation reste assez simple, un grande nombre de variante existe. On peut rajouter des termes de disparition des 2 espèces (dus à la pêche, chasse, pesticide …), tenir compte de la capacité d’accueil du milieu en utilisant un terme logistique.</p>

<h3 id="compétition"><em>Compétition</em></h3>

<p>Le modèle de compétition de Lotka-Volterra est une variante du modèle de prédation où les 2 espèces n’ont pas une hierarchie de proies et prédateurs mais sont en compétition l’une et l’autre. De plus, la dynamique de base n’est plus une simple croissance exponentielle mais logistique (avec les paramètres $r_i$ et $K_i$) :</p>

\[\left\{
  \begin{array}{ccc}
    x_1'(t) = r_1x_1(t)\left(1- \frac{x_1(t)+\alpha_{12}x_2(t)}{K_1}\right) \\
    x_2'(t) = r_2x_2(t)\left(1- \frac{x_2(t)+\alpha_{21}x_1(t)}{K_2}\right)
  \end{array}
\right.\]

<p class="text-justify">avec $\alpha_{12}$ l’effet de l’espèce 2 sur la population de l’espèce 1 et réciproquement $\alpha{21}$ l’effet de l’espèce 2 sur l’espèce 1. Par exemple, pour l’équation de l’espèce 1, le coefficient $\alpha_{12}$ est multiplié par la taille de la population $x_2$. Quand $\alpha_{12} &lt; 1$ alors l’effet de l’espèce 2 sur l’espèce 1 est plus petit que l’effet de l’espèce 1 sur ces propres membres. Et inversement, quand $\alpha_{12} &gt; 1$, l’effet de l’espèce 2 sur l’espèce 1 est supérieur à l’effet de l’espèce 1 sur ces propres membres.</p>

<p align="center">
   <img src="/assets/images/competition_interspecific.jfif" width="60%" />
</p>

<p>Pour comprendre plus en détails les prédictions du modèles, il est utile de tracer comme précédemment les diagrammes d’espace de phase $(x_1,x_2)$. On peut distinguer 4 scénarios selon les valeurs des coefficients de compétition, j’affiche ci-dessous les champs de vecteurs de ces scénarios avec <code class="language-plaintext highlighter-rouge">plt.streamplot()</code> ainsi que les isoclines, les courbes pour lesquelles \(x_1'(t)=0\) ou \(x_2'(t)=0\):</p>

<p align="center">
  <img src="/assets/images/lotka_volterra_graph3.png" width="70%" />
</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># define ODE to resolve
</span><span class="n">r1</span><span class="p">,</span> <span class="n">K1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">r2</span><span class="p">,</span> <span class="n">K2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">competition</span><span class="p">(</span><span class="n">X1X2</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
    <span class="n">dX1</span> <span class="o">=</span> <span class="n">r1</span><span class="o">*</span><span class="n">X1X2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">X1X2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">a1</span><span class="o">*</span><span class="n">X1X2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">K1</span><span class="p">)</span>
    <span class="n">dX2</span> <span class="o">=</span> <span class="n">r2</span><span class="o">*</span><span class="n">X1X2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">X1X2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">a2</span><span class="o">*</span><span class="n">X1X2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">K2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dX1</span><span class="p">,</span> <span class="n">dX2</span><span class="p">]</span>
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># compute derivatives for each scenario
</span><span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">X_grid</span><span class="p">,</span> <span class="n">Y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">DX_grid</span><span class="p">,</span> <span class="n">DY_grid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)),</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],[</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">]])</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
    <span class="n">DX_grid</span><span class="p">[</span><span class="n">k</span><span class="p">,:],</span> <span class="n">DY_grid</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">competition</span><span class="p">([</span><span class="n">X_grid</span><span class="p">,</span> <span class="n">Y_grid</span><span class="p">],</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
</code></pre></div></div>

<p>Au final, les 4 comportements possibles en fonction de $\alpha_{12}$ et $\alpha_{21}$ sont les suivants :</p>

<ol>
  <li>Exclusion compétitive d’une des deux espèces en fonction des conditions initiales.</li>
  <li>Coexistence stable des deux espèces.</li>
  <li>Exclusion compétitive de l’espèce 1 par l’espèce 2.</li>
  <li>Exclusion compétitive de l’espèce 2 par l’espèce 1.</li>
</ol>

<p>La coexistence stable des 2 espèces n’est possible que si $\alpha_{12} &lt; 1$ et $\alpha_{21} &lt; 1$, c’est-à-dire qu’il faut que la <em>compétition interspécifique</em> soit plus faible que la <em>compétition intraspécifique</em>.</p>

<h2 id="méthode-numérique-pour-les-edo">Méthode numérique pour les EDO</h2>

<p class="text-justify">Cette section est un petit peu à part du réel sujet de ce post puisque j’y introduis les méthodes numériques pour résoudre les équations différentielles. En effet, il est possible de déduire de nombreuses propriétés d’un système d’EDO en se basant sur les théorèmes mathématiques pour la théorie des systèmes dynamiques (comme <a href="https://fr.wikipedia.org/wiki/Stabilit%C3%A9_de_Liapounov">méthode de Lyapunov</a>, <a href="https://en.wikipedia.org/wiki/LaSalle%27s_invariance_principle">invariance de LaSalle</a>, <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_de_Poincar%C3%A9-Bendixson">théorème de Poincaré-Bendixon</a> …) mais seul un nombre restreint d’équations différentielles admettent une solution analytique. En pratique, on préfère souvent avoir une méthode qui calcule une solution approximative du problème. On considère le problème \(y'(t) = f\big(t,y(t)\big)\) avec $y(t_0)=y_0$. L’idée des méthodes numériques est de résoudre le problème sur un ensemble discret de points $(t_n,y_n)$ avec $h_n=t_{n+1}-t_n$, un pas de temps fixé.</p>

<p><strong>Euler</strong></p>

<p class="text-justify"><img src="/assets/images/euler_method.png" alt="image-right" class="align-right" width="30%" /> La méthode d’Euler est la plus basique des méthodes numériques pour EDO, elle utilise l’équation différentielle pour calculer la pente de la tangente à n’importe quel point de la courbe solution. La solution est approchée en partant du point initial $y_0$ connu pour lequel on calcule la tangente, on fait ensuite un pas de temps le long de cette tangente on obtient alors un nouveau point $y_1$. L’idée est de répéter ce processus, pour un pas de temps de $t_n$ à $t_{n+1}$ on peut l’écrire comme $y_{n+1} = y_n + h f(t_n,y_n)$.</p>

<p>Cette méthode est très simple à mettre en place, par exemple en python :</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Euler_method</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="p">)))</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">y0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">y</span>
</code></pre></div></div>

<p><strong>Runge-Kutta</strong></p>

<p class="text-justify"><img src="/assets/images/rungekutta_method.png" alt="image-right" class="align-right" width="45%" /> And now we’re going to shift things to the <strong>right align</strong>. Again, there should be plenty of room above, below, and to the left of the image. Just look at him there — Hey guy! Way to rock that right side. I don’t care what the left aligned image says, you look great. Don’t let anyone else tell you differently. $ y_{n+1} = y_n + \frac{h}{6} (k_1+2k_2+2k_3+k_4) $</p>

<p>test</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">RungeKutta4_method</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="p">)))</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">k1</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">k2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">k3</span><span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>
</code></pre></div></div>

<p><strong>Exemple</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># initial condition
</span><span class="n">y0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1"># discretization
</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># ODE formulation
</span><span class="k">def</span> <span class="nf">problem</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1"># analytic solution
</span><span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">y0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">y_exact</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">y_euler</span> <span class="o">=</span> <span class="n">Euler_method</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">y_rk4</span>   <span class="o">=</span> <span class="n">RungeKutta4_method</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>    
</code></pre></div></div>
<p>La méthode RK4 est une méthode d’ordre 4, ce qui signifie que l’erreur commise à chaque étape est de l’ordre de h5, alors que l’erreur totale accumulée est de l’ordre de h4.</p>

<p>The Euler method is a first-order method, which means that the local error (error per step) is proportional to the square of the step size, and the global error (error at a given time) is proportional to the step size</p>

<p align="center">
   <img src="/assets/images/numerical_ODE.gif" width="70%" />
</p>

<hr />

<p><a href="https://github.com/julienguegan/notebooks_blog/blob/main/dynamique_population.ipynb"><img src="https://img.shields.io/badge/voir_le_code_complet-github-black.svg?style=plastic&amp;logo=github" alt="Generic badge" /></a> <a href="https://jupyter.org/try"><img src="https://img.shields.io/badge/écrit_avec-Jupyter_notebook-orange.svg?style=plastic&amp;logo=Jupyter" alt="Generic badge" /></a> <a href="https://lbesson.mit-license.org/"><img src="https://img.shields.io/badge/License-MIT-blue.svg?style=plastic" alt="Generic badge" /></a></p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Le terme ordinaire est utilisé par opposition au terme équation différentielle partielle (ou équation aux dérivées partielles) où la ou les fonctions inconnues peuvent dépendre de plusieurs variables. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags : </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#mod%C3%A9lisation" class="page__taxonomy-item" rel="tag">modélisation</a><span class="sep">, </span>
    
      <a href="/tags/#%C3%A9cologie" class="page__taxonomy-item" rel="tag">écologie</a><span class="sep">, </span>
    
      <a href="/tags/#%C3%A9quation-logistique" class="page__taxonomy-item" rel="tag">équation logistique</a><span class="sep">, </span>
    
      <a href="/tags/#%C3%A9quations-diff%C3%A9rentielles-ordinaires" class="page__taxonomy-item" rel="tag">équations différentielles ordinaires</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Catégories : </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#blog" class="page__taxonomy-item" rel="tag">blog</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Mis à jour :</strong> <time datetime="2021-08-12T04:18:30+02:00">August 12, 2021</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2021-08-02-objet_fractal/" class="pagination--pager" title="Objet Fractal : Dimension, Auto-similarité, Infini
">Précédent</a>
    
    
      <a href="/posts/2021-08-21-optimisation_profil_aile/" class="pagination--pager" title="Optimisation de profil d’aile
">Suivant</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Entrez votre recherche..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Contact</strong></li>
    

    
      
        
          <li><a href="https://www.facebook.com/julien.guegan.754" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-facebook-square" aria-hidden="true"></i> Facebook</a></li>
        
      
        
          <li><a href="https://github.com/julienguegan" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.instagram.com/julien_guegan_/?hl=fr" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i> Instagram</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/julien-gu%C3%A9gan-852a30138/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> Linkedin</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Flux</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Blog du Julien. Propulsé par <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>



      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'julienguegan/julienguegan.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
